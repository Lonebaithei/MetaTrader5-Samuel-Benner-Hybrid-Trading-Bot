"""
MetaTrader 5 - Benner-Adjusted Hybrid Trading Strategy v3.0
ENTERPRISE EDITION - Production Ready

Author: Strategic Trading System
Date: January 2026
Version: 3.0 - Complete rewrite with all critical fixes

NEW FEATURES v3.0:
‚úì Environment-based configuration (no hardcoded passwords)
‚úì Weekend trading prevention
‚úì Total exposure management
‚úì Correlation risk management
‚úì Performance tracking with win rate
‚úì Telegram alerts
‚úì Trade journal (CSV export)
‚úì Dry-run mode for safe testing
‚úì Log rotation
‚úì Trailing stops
‚úì Enhanced error handling
‚úì Risk management dashboard
‚úì Comprehensive test suite

REQUIREMENTS:
pip install MetaTrader5 pandas numpy yfinance python-dotenv requests
pip install pytest  # For testing
"""

import MetaTrader5 as mt5
import pandas as pd
import numpy as np
from datetime import datetime, timedelta, timezone
import time
import logging
from logging.handlers import RotatingFileHandler
import sys
import os
import json
import csv
from typing import Dict, List, Tuple, Optional
from pathlib import Path

# Environment variables
try:
    from dotenv import load_dotenv
    load_dotenv()
    DOTENV_AVAILABLE = True
except ImportError:
    DOTENV_AVAILABLE = False
    print("WARNING: python-dotenv not installed. Using defaults.")

# External APIs
try:
    import yfinance as yf
    YFINANCE_AVAILABLE = True
except ImportError:
    YFINANCE_AVAILABLE = False

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False


# ============================================================================
# CONFIGURATION
# ============================================================================

class Config:
    """Trading Strategy Configuration"""

    # MT5 Connection (FROM ENVIRONMENT VARIABLES)
    MT5_LOGIN = int(os.getenv('MT5_LOGIN', '0'))
    MT5_PASSWORD = os.getenv('MT5_PASSWORD', '')
    MT5_SERVER = os.getenv('MT5_SERVER', 'Deriv-Demo')

    # Trading Mode
    DRY_RUN = os.getenv('DRY_RUN', 'True').lower() == 'true'  # Safe default
    
    # Trading Symbols
    SYMBOLS = {
        'mean_reversion': ['EURUSD', 'USDJPY', 'AUDUSD', 'XAUUSD'],
        'momentum': ['EURUSD', 'XAUUSD'],
        'defensive': ['XAUUSD', 'USDCHF']
    }
    
    # Symbol Correlation Matrix (to avoid over-exposure)
    CORRELATION_THRESHOLD = 0.70
    CORRELATIONS = {
        ('EURUSD', 'GBPUSD'): 0.80,
        ('EURUSD', 'AUDUSD'): 0.75,
        ('GBPUSD', 'AUDUSD'): 0.70,
    }

    # Benner Cycle Calendar
    BENNER_CALENDAR = {
        'Jan-2026': {'allocation': 0.50, 'phase': 'Selective Accumulation'},
        'Feb-2026': {'allocation': 0.60, 'phase': 'Build Positions'},
        'Mar-2026': {'allocation': 0.75, 'phase': 'Active Trading'},
        'Apr-2026': {'allocation': 0.60, 'phase': 'Take Profits'},
        'May-2026': {'allocation': 0.40, 'phase': 'Exit Mode'},
        'Jun-2026': {'allocation': 0.20, 'phase': 'Defensive'}
    }

    # Risk Management
    MAX_POSITION_SIZE_PCT = 0.02  # 2% risk per trade
    MAX_TOTAL_EXPOSURE_PCT = 0.30  # 30% total exposure
    STOP_LOSS_PIPS = 50
    TAKE_PROFIT_PIPS = 100
    TRAILING_STOP_PIPS = 30  # NEW: Trailing stop distance
    
    # Signal Filters
    RSI_BUY_THRESHOLD = 40  # Only buy if RSI below this
    REQUIRE_200MA_FILTER = True  # Require price above 200MA for buys

    # Technical Indicators
    BB_PERIOD = 20
    BB_STD = 2
    RSI_PERIOD = 14
    RSI_OVERSOLD = 30
    RSI_OVERBOUGHT = 70
    MA_FAST = 20
    MA_SLOW = 50
    MA_LONG = 200

    # Market Warning Levels
    VIX_WARNING = 20
    VIX_CRITICAL = 25
    SPX_SUPPORT = 6600

    # Trading Parameters
    MAGIC_MEAN_REVERSION = 123456
    MAGIC_MOMENTUM = 123457
    MAGIC_DEFENSIVE = 123458
    SLIPPAGE = 10
    UPDATE_INTERVAL = 300  # 5 minutes
    MIN_BARS_REQUIRED = 250

    # Market Data Settings
    USE_EXTERNAL_API = True
    MAX_DATA_AGE_HOURS = 48
    VIX_SYMBOLS = ['VIX', 'VIXC', 'VIX.F', 'VIX.IDX', '#VIX', 'VOLATILITY']
    SPX_SYMBOLS = ['SPX500', 'US500', 'SPX', 'SP500', '#SPX', 'US500.IDX']

    # Telegram Alerts (optional)
    TELEGRAM_ENABLED = os.getenv('TELEGRAM_ENABLED', 'False').lower() == 'true'
    TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '')
    TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', '')

    # Logging
    LOG_FILE = 'benner_bot_v3.log'
    LOG_LEVEL = logging.INFO
    LOG_MAX_BYTES = 10 * 1024 * 1024  # 10 MB
    LOG_BACKUP_COUNT = 5
    
    # Trade Journal
    TRADE_JOURNAL_FILE = 'trade_journal.csv'
    PERFORMANCE_FILE = 'performance_stats.json'

    @classmethod
    def validate(cls):
        """Validate configuration"""
        errors = []
        
        if cls.MT5_LOGIN == 0:
            errors.append("MT5_LOGIN not set in environment variables")
        if not cls.MT5_PASSWORD:
            errors.append("MT5_PASSWORD not set in environment variables")
        if not cls.MT5_SERVER:
            errors.append("MT5_SERVER not set in environment variables")
        
        if cls.TELEGRAM_ENABLED and (not cls.TELEGRAM_BOT_TOKEN or not cls.TELEGRAM_CHAT_ID):
            errors.append("Telegram enabled but TOKEN or CHAT_ID not set")
        
        return errors


# ============================================================================
# LOGGING SETUP
# ============================================================================

def setup_logging():
    """Setup logging with rotation"""
    # Rotating file handler
    file_handler = RotatingFileHandler(
        Config.LOG_FILE,
        maxBytes=Config.LOG_MAX_BYTES,
        backupCount=Config.LOG_BACKUP_COUNT,
        encoding='utf-8'
    )
    file_handler.setLevel(Config.LOG_LEVEL)

    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(Config.LOG_LEVEL)

    # Formatter
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)

    # Setup logger
    logger = logging.getLogger(__name__)
    logger.setLevel(Config.LOG_LEVEL)
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)

    return logger

logger = setup_logging()


# ============================================================================
# ALERT SYSTEM
# ============================================================================

class AlertSystem:
    """Send alerts via Telegram"""
    
    def __init__(self):
        self.enabled = Config.TELEGRAM_ENABLED and REQUESTS_AVAILABLE
        self.bot_token = Config.TELEGRAM_BOT_TOKEN
        self.chat_id = Config.TELEGRAM_CHAT_ID
        
        if Config.TELEGRAM_ENABLED and not REQUESTS_AVAILABLE:
            logger.warning("Telegram enabled but 'requests' not installed")
            self.enabled = False
    
    def send(self, message: str, priority: str = 'INFO'):
        """Send Telegram message"""
        if not self.enabled:
            return
        
        try:
            # Add emoji based on priority
            emoji = {
                'INFO': '‚ÑπÔ∏è',
                'SUCCESS': '‚úÖ',
                'WARNING': '‚ö†Ô∏è',
                'ERROR': '‚ùå',
                'TRADE': 'üí∞'
            }.get(priority, '‚ÑπÔ∏è')
            
            formatted_message = f"{emoji} <b>{priority}</b>\n\n{message}"
            
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            data = {
                "chat_id": self.chat_id,
                "text": formatted_message,
                "parse_mode": "HTML"
            }
            
            response = requests.post(url, data=data, timeout=10)
            
            if response.status_code == 200:
                logger.debug(f"Telegram alert sent: {priority}")
            else:
                logger.warning(f"Telegram alert failed: {response.status_code}")
                
        except Exception as e:
            logger.error(f"Error sending Telegram alert: {e}")
    
    def send_trade_alert(self, action: str, symbol: str, lots: float, 
                        price: float, sl: float, tp: float, strategy: str):
        """Send trade execution alert"""
        message = (
            f"<b>{action} {symbol}</b>\n"
            f"Lots: {lots:.3f}\n"
            f"Entry: ${price:.5f}\n"
            f"SL: ${sl:.5f}\n"
            f"TP: ${tp:.5f}\n"
            f"Strategy: {strategy}"
        )
        self.send(message, 'TRADE')
    
    def send_close_alert(self, symbol: str, lots: float, profit: float, reason: str):
        """Send position close alert"""
        emoji = 'üü¢' if profit > 0 else 'üî¥'
        message = (
            f"{emoji} <b>CLOSED {symbol}</b>\n"
            f"Lots: {lots:.3f}\n"
            f"Profit: ${profit:.2f}\n"
            f"Reason: {reason}"
        )
        self.send(message, 'TRADE')


# ============================================================================
# PERFORMANCE TRACKER
# ============================================================================

class PerformanceTracker:
    """Track bot performance and statistics"""
    
    def __init__(self):
        self.trades = []
        self.daily_pnl = {}
        self.load_history()
    
    def load_history(self):
        """Load trade history from file"""
        try:
            if os.path.exists(Config.PERFORMANCE_FILE):
                with open(Config.PERFORMANCE_FILE, 'r') as f:
                    data = json.load(f)
                    self.trades = data.get('trades', [])
                    self.daily_pnl = data.get('daily_pnl', {})
                logger.info(f"Loaded {len(self.trades)} historical trades")
        except Exception as e:
            logger.error(f"Error loading performance history: {e}")
    
    def save_history(self):
        """Save trade history to file"""
        try:
            data = {
                'trades': self.trades,
                'daily_pnl': self.daily_pnl,
                'last_updated': datetime.now().isoformat()
            }
            with open(Config.PERFORMANCE_FILE, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"Error saving performance history: {e}")
    
    def record_trade(self, symbol: str, action: str, lots: float, entry: float,
                    exit_price: float, profit: float, strategy: str, reason: str):
        """Record a completed trade"""
        trade = {
            'timestamp': datetime.now().isoformat(),
            'symbol': symbol,
            'action': action,
            'lots': lots,
            'entry': entry,
            'exit': exit_price,
            'profit': profit,
            'profit_pct': (profit / (lots * entry * 100000)) * 100 if entry > 0 else 0,
            'strategy': strategy,
            'reason': reason
        }
        
        self.trades.append(trade)
        
        # Update daily P/L
        date = datetime.now().strftime('%Y-%m-%d')
        self.daily_pnl[date] = self.daily_pnl.get(date, 0) + profit
        
        # Save to CSV journal
        self._append_to_journal(trade)
        
        # Save to JSON
        self.save_history()
        
        # Calculate and log statistics
        self._log_statistics()
    
    def _append_to_journal(self, trade: Dict):
        """Append trade to CSV journal"""
        try:
            file_exists = os.path.exists(Config.TRADE_JOURNAL_FILE)
            
            with open(Config.TRADE_JOURNAL_FILE, 'a', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=trade.keys())
                
                if not file_exists:
                    writer.writeheader()
                
                writer.writerow(trade)
                
        except Exception as e:
            logger.error(f"Error writing to trade journal: {e}")
    
    def _log_statistics(self):
        """Calculate and log performance statistics"""
        if not self.trades:
            return
        
        total_trades = len(self.trades)
        wins = len([t for t in self.trades if t['profit'] > 0])
        losses = len([t for t in self.trades if t['profit'] < 0])
        
        win_rate = (wins / total_trades * 100) if total_trades > 0 else 0
        
        total_profit = sum(t['profit'] for t in self.trades)
        avg_win = np.mean([t['profit'] for t in self.trades if t['profit'] > 0]) if wins > 0 else 0
        avg_loss = np.mean([t['profit'] for t in self.trades if t['profit'] < 0]) if losses > 0 else 0
        
        profit_factor = abs(avg_win * wins / (avg_loss * losses)) if losses > 0 and avg_loss != 0 else 0
        
        logger.info(f"\n{'='*60}")
        logger.info(f"PERFORMANCE STATISTICS")
        logger.info(f"{'='*60}")
        logger.info(f"Total Trades: {total_trades}")
        logger.info(f"Wins: {wins} | Losses: {losses}")
        logger.info(f"Win Rate: {win_rate:.1f}%")
        logger.info(f"Total P/L: ${total_profit:.2f}")
        logger.info(f"Avg Win: ${avg_win:.2f} | Avg Loss: ${avg_loss:.2f}")
        logger.info(f"Profit Factor: {profit_factor:.2f}")
        logger.info(f"{'='*60}\n")
    
    def get_statistics(self) -> Dict:
        """Get current performance statistics"""
        if not self.trades:
            return {
                'total_trades': 0,
                'win_rate': 0,
                'total_profit': 0,
                'profit_factor': 0
            }
        
        total_trades = len(self.trades)
        wins = len([t for t in self.trades if t['profit'] > 0])
        losses = len([t for t in self.trades if t['profit'] < 0])
        
        win_rate = (wins / total_trades * 100) if total_trades > 0 else 0
        total_profit = sum(t['profit'] for t in self.trades)
        
        avg_win = np.mean([t['profit'] for t in self.trades if t['profit'] > 0]) if wins > 0 else 0
        avg_loss = np.mean([t['profit'] for t in self.trades if t['profit'] < 0]) if losses > 0 else 0
        profit_factor = abs(avg_win * wins / (avg_loss * losses)) if losses > 0 and avg_loss != 0 else 0
        
        return {
            'total_trades': total_trades,
            'wins': wins,
            'losses': losses,
            'win_rate': win_rate,
            'total_profit': total_profit,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'profit_factor': profit_factor
        }


# ============================================================================
# WEEKEND/MARKET HOURS CHECK
# ============================================================================

class MarketHours:
    """Check if market is open (Forex 24/5)"""
    
    @staticmethod
    def is_weekend() -> bool:
        """Check if it's weekend (market closed)"""
        now = datetime.now(timezone.utc)
        
        # Saturday (5) or Sunday before 22:00 (6)
        if now.weekday() == 5:  # Saturday
            return True
        
        if now.weekday() == 6:  # Sunday
            if now.hour < 22:  # Market opens Sunday 22:00 UTC
                return True
        
        # Friday after 22:00 UTC (market closes)
        if now.weekday() == 4 and now.hour >= 22:
            return True
        
        return False
    
    @staticmethod
    def next_open_time() -> datetime:
        """Calculate when market opens next"""
        now = datetime.now(timezone.utc)
        
        # If Friday after close or Saturday, next open is Sunday 22:00
        if (now.weekday() == 4 and now.hour >= 22) or now.weekday() == 5:
            days_until_sunday = (6 - now.weekday()) % 7
            next_open = now.replace(hour=22, minute=0, second=0, microsecond=0)
            next_open += timedelta(days=days_until_sunday)
            return next_open
        
        # If Sunday before 22:00
        if now.weekday() == 6 and now.hour < 22:
            return now.replace(hour=22, minute=0, second=0, microsecond=0)
        
        return now  # Market is open


# ============================================================================
# RISK MANAGER
# ============================================================================

class RiskManager:
    """Manage overall portfolio risk"""
    
    def __init__(self):
        self.max_exposure = Config.MAX_TOTAL_EXPOSURE_PCT
        self.correlation_threshold = Config.CORRELATION_THRESHOLD
    
    def check_total_exposure(self, current_exposure: float) -> bool:
        """Check if current exposure is within limits"""
        if current_exposure >= self.max_exposure:
            logger.warning(f"Portfolio at max exposure: {current_exposure*100:.1f}%")
            return False
        return True
    
    def is_correlated(self, symbol1: str, symbol2: str) -> bool:
        """Check if two symbols are highly correlated"""
        pair = tuple(sorted([symbol1, symbol2]))
        correlation = Config.CORRELATIONS.get(pair, 0)
        
        return correlation > self.correlation_threshold
    
    def check_correlation_risk(self, new_symbol: str) -> bool:
        """Check if opening new position creates correlation risk"""
        positions = mt5.positions_get()
        if not positions:
            return True  # No positions, no risk
        
        for pos in positions:
            if self.is_correlated(new_symbol, pos.symbol):
                logger.warning(
                    f"High correlation between {new_symbol} and {pos.symbol} "
                    f"({Config.CORRELATIONS.get(tuple(sorted([new_symbol, pos.symbol])), 0):.2f})"
                )
                return False
        
        return True
    
    def can_open_position(self, symbol: str, current_exposure: float) -> Tuple[bool, str]:
        """Comprehensive check if we can open a new position"""
        # Check exposure
        if not self.check_total_exposure(current_exposure):
            return False, f"Max exposure reached ({current_exposure*100:.1f}%)"
        
        # Check correlation
        if not self.check_correlation_risk(symbol):
            return False, f"High correlation risk with existing positions"
        
        # Check for duplicate
        positions = mt5.positions_get(symbol=symbol)
        if positions and len(positions) > 0:
            return False, f"Already have position in {symbol}"
        
        return True, "OK"


# ============================================================================
# TECHNICAL INDICATORS (unchanged from v2.3)
# ============================================================================

class TechnicalIndicators:
    """Calculate technical indicators for trading signals"""

    @staticmethod
    def bollinger_bands(data: pd.DataFrame, period: int = 20, std: int = 2) -> pd.DataFrame:
        data['bb_middle'] = data['close'].rolling(window=period).mean()
        data['bb_std'] = data['close'].rolling(window=period).std()
        data['bb_upper'] = data['bb_middle'] + (std * data['bb_std'])
        data['bb_lower'] = data['bb_middle'] - (std * data['bb_std'])
        return data

    @staticmethod
    def rsi(data: pd.DataFrame, period: int = 14) -> pd.DataFrame:
        delta = data['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss.replace(0, 0.0001)
        data['rsi'] = 100 - (100 / (1 + rs))
        return data

    @staticmethod
    def moving_averages(data: pd.DataFrame, fast: int = 20, slow: int = 50, long: int = 200) -> pd.DataFrame:
        data['ma_fast'] = data['close'].rolling(window=fast).mean()
        data['ma_slow'] = data['close'].rolling(window=slow).mean()
        data['ma_200'] = data['close'].rolling(window=long).mean()
        return data

    @staticmethod
    def volume_analysis(data: pd.DataFrame, period: int = 20) -> pd.DataFrame:
        data['volume_avg'] = data['tick_volume'].rolling(window=period).mean()
        data['volume_spike'] = data['tick_volume'] > (data['volume_avg'] * 2)
        return data


# ============================================================================
# MARKET DATA PROVIDER (same as v2.3 but with minor fixes)
# ============================================================================

class MarketDataProvider:
    """Fetch VIX and SPX data from MT5 or external APIs with caching"""
    
    def __init__(self):
        self._vix_symbol = None
        self._spx_symbol = None
        self._last_vix_value = 20.5
        self._last_spx_value = 6797.0
        self._last_update = None
        
        logger.info("[MARKET DATA] Initializing market data provider...")
        self._discover_symbols()
    
    def _discover_symbols(self):
        logger.info("[MARKET DATA] Discovering available market indicators...")
        
        for symbol in Config.VIX_SYMBOLS:
            try:
                rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_D1, 0, 1)
                if rates is not None and len(rates) > 0:
                    self._vix_symbol = symbol
                    self._last_vix_value = rates[0]['close']
                    logger.info(f"[VIX] Found working symbol: {symbol} = {self._last_vix_value:.2f}")
                    break
            except Exception:
                continue
        
        if self._vix_symbol is None:
            logger.warning("[VIX] No MT5 symbol found - will use external API or default")
        
        for symbol in Config.SPX_SYMBOLS:
            try:
                rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_D1, 0, 1)
                if rates is not None and len(rates) > 0:
                    self._spx_symbol = symbol
                    self._last_spx_value = rates[0]['close']
                    logger.info(f"[SPX] Found working symbol: {symbol} = {self._last_spx_value:.2f}")
                    break
            except Exception:
                continue
        
        if self._spx_symbol is None:
            logger.warning("[SPX] No MT5 symbol found - will use external API or default")
    
    def _validate_data_freshness(self, timestamp: int) -> bool:
        data_time = datetime.fromtimestamp(timestamp, tz=timezone.utc)
        age_hours = (datetime.now(timezone.utc) - data_time).total_seconds() / 3600
        
        if age_hours > Config.MAX_DATA_AGE_HOURS:
            logger.warning(f"Data is {age_hours:.1f} hours old (max: {Config.MAX_DATA_AGE_HOURS})")
            return False
        
        return True
    
    def _get_from_mt5(self, symbol: str, name: str) -> Optional[float]:
        try:
            rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_D1, 0, 1)
            
            if rates is not None and len(rates) > 0:
                if not self._validate_data_freshness(rates[0]['time']):
                    return None
                
                value = rates[0]['close']
                logger.debug(f"[{name}] MT5 data: {symbol} = {value:.2f}")
                return value
            
        except Exception as e:
            logger.debug(f"[{name}] MT5 fetch failed for {symbol}: {e}")
        
        return None
    
    def _get_from_yfinance(self) -> Dict[str, Optional[float]]:
        if not YFINANCE_AVAILABLE:
            return {'vix': None, 'spx': None}
        
        try:
            logger.info("[EXTERNAL API] Fetching data from Yahoo Finance...")
            
            vix_value = None
            try:
                vix_ticker = yf.Ticker("^VIX")
                vix_data = vix_ticker.history(period='1d')
                if not vix_data.empty:
                    vix_value = float(vix_data['Close'].iloc[-1])
                    logger.info(f"[VIX] Yahoo Finance: {vix_value:.2f}")
            except Exception as e:
                logger.warning(f"[VIX] Yahoo Finance fetch failed: {e}")
            
            spx_value = None
            try:
                spx_ticker = yf.Ticker("^GSPC")
                spx_data = spx_ticker.history(period='1d')
                if not spx_data.empty:
                    spx_value = float(spx_data['Close'].iloc[-1])
                    logger.info(f"[SPX] Yahoo Finance: {spx_value:.2f}")
            except Exception as e:
                logger.warning(f"[SPX] Yahoo Finance fetch failed: {e}")
            
            return {'vix': vix_value, 'spx': spx_value}
            
        except Exception as e:
            logger.error(f"[EXTERNAL API] Yahoo Finance error: {e}")
            return {'vix': None, 'spx': None}
    
    def get_market_indicators(self) -> Dict[str, any]:
        vix_value = self._last_vix_value
        spx_value = self._last_spx_value
        vix_source = 'CACHED'
        spx_source = 'CACHED'
        
        if self._vix_symbol:
            mt5_vix = self._get_from_mt5(self._vix_symbol, 'VIX')
            if mt5_vix is not None:
                vix_value = mt5_vix
                vix_source = f'MT5:{self._vix_symbol}'
            else:
                self._vix_symbol = None
        
        if self._spx_symbol:
            mt5_spx = self._get_from_mt5(self._spx_symbol, 'SPX')
            if mt5_spx is not None:
                spx_value = mt5_spx
                spx_source = f'MT5:{self._spx_symbol}'
            else:
                self._spx_symbol = None
        
        if self._vix_symbol is None or self._spx_symbol is None:
            self._discover_symbols()
        
        if Config.USE_EXTERNAL_API and (self._vix_symbol is None or self._spx_symbol is None):
            external_data = self._get_from_yfinance()
            
            if external_data['vix'] is not None and self._vix_symbol is None:
                vix_value = external_data['vix']
                vix_source = 'Yahoo Finance'
            
            if external_data['spx'] is not None and self._spx_symbol is None:
                spx_value = external_data['spx']
                spx_source = 'Yahoo Finance'
        
        self._last_vix_value = vix_value
        self._last_spx_value = spx_value
        self._last_update = datetime.now(timezone.utc)
        
        return {
            'vix': vix_value,
            'spx': spx_value,
            'vix_source': vix_source,
            'spx_source': spx_source,
            'last_update': self._last_update
        }


# Continuing in next artifact due to length...
